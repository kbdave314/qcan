////////////////////////////////////////////////////////////
version="version fermiweyl.lib 0.1.0.0 Sep_2016";
category="Noncommutative";
info="
LIBRARY: fermiweyl.lib fermionic Weyl algebra tools
AUTHORS: Dave, K.,  kdave@mit.edu

OVERVIEW:

PROCEDURES:
PSWeyl([p]);         create pure super Weyl algebra,
makePSWeyl();        pure s. W. alg. over Q or Fp,
structureMatrix(k);  matrix of basis monomial products";

////////////////////////////////////////////////////////////
LIB "matrix.lib";

/* Amalgamation of Exterior and Weyl from nctools.lib. */
proc PSWeyl(list #)
"USAGE:    PSWeyl()
RETURN:   qring
PURPOSE:  create a pure super Weyl algebra structure.
NOTE: Activate this ring using the command @code(setring).
@*    Assume the number of variables of a basering is 2k.
(if the number of variables is odd, an error message will
be returned).
@*    By default, the procedure treats the first k
variables as coordinates x_i and the last k as
differentials d_i
If a nonzero optional argument is given, the procedure 
treats 2k variables of a basering as pairs (x_i,d_i),
variables with odd numbers are treated as coordinates
and with even numbers as differentials
@*    If 
EXAMPLE: example PSWeyl; shows examples
"
{
  //there are two possibilities for choosing the PBW basis.
  //The variables have names x(i) for coordinates 
  // and d(i) for partial
  // differentiations. By default, the procedure
  //creates a ring, where the variables are ordered as 
  // x(1..n),d(1..n).  Otherwise, the tensor product-like 
  // realization x(1),d(1),x(2),d(2),... is used.
  string rname=nameof(basering);
  if ( rname == "basering") // i.e. no ring has been set yet
  {
    "You have to call the procedure from the ring";
    return();
  }
  int @chr = 0;
  if ( size(#) > 0 )
  {
    if ( typeof( #[1] ) == "int" )
    {
      @chr = #[1];
    }
  }
  int nv = nvars(basering);
  int N = nv div 2;
  if ((nv % 2) != 0)
  {
    "Cannot create structure for an odd generating set";
    return();
  }
  int i;
  matrix @D[nv][nv];
  for ( i=1; i<=N; i++ )
  {
    if ( @chr==0 ) // default
    {
      @D[i,N+i]=1;
    }
    else
    {
      @D[2*i-1,2*i]=1;
    }
  }
  def @@RR = nc_algebra(-1,@D); 
  setring @@RR;
  ideal Q;
  for ( i=1; i<=nv; i++ )
  {
    Q[i] = var(i)^2;
  }
  Q = twostd(Q);
  qring @EA = Q;
  return(@EA);
}
example
{
  "EXAMPLE:";echo=2;
  ring A1=0,(x(1..2),d(1..2)),dp;
  def S=PSWeyl();
  setring S;  S;
  kill A1,S;
  ring B1=0,(x1,d1,x2,d2),dp;
  def S=PSWeyl(1);
  setring S;  S;
}


proc makePSWeyl(int n, list #)
"USAGE:  makePSWeyl(n,[p]); n an integer, n>0; p an optional integer (field characteristic)
RETURN:  ring
PURPOSE: create the n-th pure super Weyl algebra over the rationals Q or F_p
NOTE:    activate this ring with the \"setring\" command.
@*       The presentation of an n-th super Weyl algebra is classical: D(i)x(i)=-x(i)D(i)+1,
@*       where x(i) correspond to coordinates and D(i) to partial differentiations, i=1,...,n.
@*       If p is not prime, the next larger prime number will be used.
SEE ALSO: PSWeyl
EXAMPLE: example makePSWeyl; shows examples
"{
  if (n<1)
  {
    print("Incorrect input");
    return();
  }
  int @p = 0;
  if ( size(#) > 0 )
  {
    if ( typeof( #[1] ) == "int" )
    {
      @p = #[1];
    }
  }
  if (n ==1)
  {
    ring @rr = @p,(x,D),dp;
  }
  else
  {
    ring @rr = @p,(x(1..n),D(1..n)),dp;
  }
  setring @rr;
  def @rrr = PSWeyl();
  return(@rrr);
}
example
{ "EXAMPLE:"; echo = 2;
   def a = makePSWeyl(3);
   setring a;
   a;
}

proc basebydeg(int k)
"USAGE: basebydeg(k); k an integer, k>=0
RETURN: column matrix in ring
PURPOSE: return all basis elements in degrevlex order
up through degree k
" {
  if (k<0)
  {
    print("Incorrect input");
    return();
  }
  int i;
  matrix basis = matrix(kbase(std(0),0));
  matrix subbasis;
  if (k>=1) 
  {
    for(i=1; i<=k; i++) {
      subbasis = matrix(kbase(std(0),i));
      if (subbasis[1,1] != 0) {
        basis = concat(basis, subbasis);
      }
    }
  }
  return(basis);
} example {
  ring A4=0,(x(1..4),d(1..4)),dp;
  def S=PSWeyl();
  setring S;
  basebydeg(2);
}


proc structureMatrix(int k)
"USAGE: structureMatrix(k); k an integer, k>=0
RETURN: matrix in ring
PURPOSE:  produce the matrix of all
products of basis elements of degree at most k
in the basering.
EXAMPLE: example structureMatrix; shows examples
"{
  if (k<0)
  {
    print("Incorrect input");
    return();
  }
  matrix basis = basebydeg(k);
  int thesize = size(basis);
  matrix allproducts[thesize][thesize];
  int i;
  int j;
  for(i=1; i<=thesize; i++) {
    for(j=1; j<=thesize; j++) {
    allproducts[i, j] = reduce(basis[1,i]*basis[1,j],std(0));
    }
  }
  return(allproducts); 
} example {  
  ring A4=0,(x(1..4),d(1..4)),dp;
  def S=PSWeyl();
  setring S;
  structureMatrix(2);
}

proc structureConstantsFor(int k, int l)
"USAGE: structureConstantsFor(k, l); k an integer, k>=0;
l an integer, l of right degree;
RETURN: matrix in ring
PURPOSE: produce matrix of coefficients for which given
monomial appears.
"{
  if (k<0 || l<0)
  {
    print("Incorrect input");
    return();
  }
  matrix basis = basebydeg(k);
  int thesize = size(basis);
  print(thesize);
  if (l>thesize)
  {
    print("Incorrect input");
    return();
  }
  matrix allproducts = structureMatrix(k);
  int i;
  int j;
  poly basiselement = lead(basis[1,l]);
  for(i=1; i<=thesize; i++) {
    for(j=1; j<=thesize; j++) {
    print(coef(allproducts[i,j], basiselement));
    }
  }
  return(); 
}
